<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta name="google-site-verification" content="OcsZXBpQqAp8163-20wn3epncmCv_UBtqBLZmspy-NA">
  
  <title>🔥 面试 | JavaScript | Arginsen&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="interviewFrontend">
  
  
  
  
  <meta name="keywords" content="interview,Frontend">
<meta property="og:type" content="article">
<meta property="og:title" content="🔥 面试 | JavaScript">
<meta property="og:url" content="https://arginsen.github.io/blog/2020/08/25/1-interview-js/index.html">
<meta property="og:site_name" content="Arginsen&#39;s Blog">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://arginsen.github.io/blog/img/interview.jpg">
<meta property="og:updated_time" content="2025-07-31T18:03:17.624Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="🔥 面试 | JavaScript">
<meta name="twitter:image" content="https://arginsen.github.io/blog/img/interview.jpg">
  
    <link rel="alternate" href="/atom.xml" title="Arginsen&#39;s Blog" type="application/atom+xml">
  
  <link rel="icon" href="/blog/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/blog/css/style.css">

  <script src="/blog/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/blog/css/bootstrap.css">
  <link rel="stylesheet" href="/blog/css/fashion.css">
  <link rel="stylesheet" href="/blog/css/glyphs.css">

</head>
</html>


  <body data-spy="scroll" data-target="#toc" data-offset="50">


  



<header id="allheader" class="site-header" role="banner" 
   >
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/blog/" title="Arginsen&#39;s Blog" rel="home"> Arginsen&#39;s Blog </a>
            
          </h1>
          
          
            <div class="site-description">smells like teen spirit</div>
          
            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>

            <div class="clearfix sf-menu">
              <ul id="main-nav" class="menu sf-js-enabled sf-arrows"  style="touch-action: pan-y;">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/blog/">首页</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/blog/archives">归档</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/blog/categories">分类</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/blog/about">关于</a> </li>
                    
              </ul>
            </div>
          </nav>
      </div>
  </div>
</header>


  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-1-interview-js" style="width: 66%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
<div class="article-gallery">
  <div class="article-gallery-photos">
    
      <a class="article-gallery-img fancybox" href="/blog/img/interview.jpg" rel="gallery_cmdraqvi00012rlpuk14z3lmj">
        <img src="/blog/img/interview.jpg" itemprop="image">
      </a>
    
  </div>
</div>

    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      🔥 面试 | JavaScript
    </h1>
  

      </header>
    

    <div class="article-entry" itemprop="articleBody">
      
        <p><br><br><a id="more"></a></p>
<p><video class="vsc-initialized" preload="auto" controls="controls"><br>    <source src="/blog/img/2020/interview1/howtointerview.mp4" type="video/mp4"><br>    Your user agent does not support the HTML5 Video element.<br></video><br><br></p>
<h1 id="js-基础数据类型有哪些（字节）"><a href="#js-基础数据类型有哪些（字节）" class="headerlink" title="js 基础数据类型有哪些（字节）"></a>js 基础数据类型有哪些（字节）</h1><p>Number、String、Boolean、null、undefined、Symbol、BigInt</p>
<p>补充：对象、数组、函数均为引用数据类型</p>
<p>基本类型的变量是存放在栈区的（栈区指内存里的栈内存），栈区包括了:变量的标识符和变量的值</p>
<p>引用类型的存储需要内存的栈区和堆区（堆区是指内存里的堆内存）共同完成，栈区内存保存 变量标识符 和 指向堆内存中该对象的指针</p>
<h1 id="对数据类型的检测（字节）"><a href="#对数据类型的检测（字节）" class="headerlink" title="对数据类型的检测（字节）"></a>对数据类型的检测（字节）</h1><ol>
<li>typeof</li>
</ol>
<p>其中 数组、对象、null 都会被判定为 object</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">2</span>);               <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>);            <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">'str'</span>);           <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> []);              <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);    <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> &#123;&#125;);              <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>);       <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>);            <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Symbol</span>());        <span class="comment">// object</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>instanceof</li>
</ol>
<p>可以判断 <strong>对象</strong> 的类型，也就是引用数据类型，不能判断原始类型数据<br>原理是判断在其原型链中能否找到该类型的原型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>);                    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);                <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'str'</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>);                <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Array</span>);                    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Function</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>);                   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>constructor</li>
</ol>
<p>constructor有两个作用，一是判断数据的类型，二是对象实例通过 constrcutor 对象访问它的构造函数。需要注意，如果创建一个对象来<strong>改变</strong>它的原型，constructor就不能用来判断数据类型了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log((<span class="number">2</span>).constructor === <span class="built_in">Number</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="literal">true</span>).constructor === <span class="built_in">Boolean</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="string">'str'</span>).constructor === <span class="built_in">String</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(([]).constructor === <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;).constructor === <span class="built_in">Function</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log((&#123;&#125;).constructor === <span class="built_in">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>Object.prototype.toString.call(obj)</li>
</ol>
<p>toString是Object的原型方法，返回对象的具体类型；<br>Array、function等类型作为Object的实例，都重写了toString方法，所以不能直接调用 toString</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="number">2</span>)); <span class="comment">// [object Number]</span></span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="literal">true</span>)); <span class="comment">// [object Boolean]</span></span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="string">'str'</span>)); <span class="comment">// [object String]</span></span><br><span class="line"><span class="built_in">console</span>.log(a.call([])); <span class="comment">// [object Array]</span></span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)); <span class="comment">// [object Function]</span></span><br><span class="line"><span class="built_in">console</span>.log(a.call(&#123;&#125;)); <span class="comment">// [object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="literal">undefined</span>)); <span class="comment">// [object Undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(a.call(<span class="literal">null</span>)); <span class="comment">// [object Null]</span></span><br></pre></td></tr></table></figure>
<h1 id="js如何判断数组是Array类型（字节）"><a href="#js如何判断数组是Array类型（字节）" class="headerlink" title="js如何判断数组是Array类型（字节）"></a>js如何判断数组是Array类型（字节）</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span> === <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.isArray(arr) === <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(arr) === <span class="string">'[object Array]'</span></span><br><span class="line"></span><br><span class="line">arr.constructor === <span class="built_in">Array</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.isPrototypeOf(arr) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h1 id="如何理解-slice-call-arguments"><a href="#如何理解-slice-call-arguments" class="headerlink" title="如何理解 [].slice.call(arguments)"></a>如何理解 [].slice.call(arguments)</h1><p>通常用该方法使一个类数组对象能够使用数组的 slice 方法，这里也就是将类数组转为数组</p>
<p>实际上 call 的用途就是改变函数的 this 指向，这里也就可以理解成 slice 函数通过 call 将 this 指向 arguments 对象，slice 在该上下文执行，传入的参数为空。当然也可以在其后添加参数描述 start 和 end</p>
<h1 id="如何检测一个空对象"><a href="#如何检测一个空对象" class="headerlink" title="如何检测一个空对象"></a>如何检测一个空对象</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.keys(obj).length === <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0-1-0-2-0-3"><a href="#0-1-0-2-0-3" class="headerlink" title="0.1 + 0.2 == 0.3 ?"></a>0.1 + 0.2 == 0.3 ?</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0.1</span> + <span class="number">0.2</span></span><br><span class="line">b = <span class="number">0.3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">numbersequal</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.abs(a-b) &lt; <span class="built_in">Number</span>.EPSILON;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="null-和-undefined-的区别"><a href="#null-和-undefined-的区别" class="headerlink" title="null 和 undefined 的区别"></a>null 和 undefined 的区别</h1><p>null 表示一个对象被定义了，但存放了空指针，转换为数值时为 0<br>undefined 表示声明的变量未初始化，转换为数值时为 NaN</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h1 id="js-中有几种类型的值"><a href="#js-中有几种类型的值" class="headerlink" title="js 中有几种类型的值"></a>js 中有几种类型的值</h1><p>基本数据类型存储在栈中；引用数据类型（对象）存储在堆中，指针放在栈中。<br>两种类型的区别是：1. 存储位置不同；2. 原始数据类型是直接存储在栈中的简单数据段，占据空间小、大小固定，属于频繁操作的对象，所以放在栈中；3. 引用数据类型是存储在堆中的对象，占据空间大、大小不固定，如果在栈中存储将会影响程序运行的性能。<br>引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</p>
<h1 id="操作符的强制类型转换规则"><a href="#操作符的强制类型转换规则" class="headerlink" title="== 操作符的强制类型转换规则"></a>== 操作符的强制类型转换规则</h1><ol>
<li>首先判断两者类型是否相同，相同的话就比较两者的大小</li>
<li>类型不同进行类型转换</li>
<li>先判断是否在对比 null 和 undefined， 是的话就会返回 true</li>
<li>再判断两者类型是否为 string 和 number，是的话将字符串转换为 number</li>
<li>接着判断一方是否为 boolean，是的话把 boolean 转换为 number 再进行判断</li>
<li>判断其中一方是否为 object 且另一方为 string、number、symbol，是的话就把  object 转换为原始类型再判断</li>
</ol>
<h1 id="String-有哪些方法（实例方法）"><a href="#String-有哪些方法（实例方法）" class="headerlink" title="String 有哪些方法（实例方法）"></a>String 有哪些方法（实例方法）</h1><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>String.prototype.concat()</td>
<td>concat方法用于<strong>连接</strong>两个字符串，返回一个新字符串，不改变原字符串</td>
</tr>
<tr>
<td>String.prototype.slice(start, end)</td>
<td>从原字符串取出子字符串并返回，不改变原字符串，返回不包含 end 的字符，如不指定 end 则直到结束</td>
</tr>
<tr>
<td>String.prototype.substring(start, end)</td>
<td>从原字符串取出子字符串并返回，不改变原字符串，参数同 slice，返回不包含 end 的字符</td>
</tr>
<tr>
<td>String.prototype.substr(start, len)</td>
<td>从原字符串取出子字符串并返回，不改变原字符串</td>
</tr>
<tr>
<td>String.prototype.indexOf()</td>
<td>用于确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始的<strong>位置</strong>，如返回-1，就表示不匹配，可以在第二个参数指定起始位置</td>
</tr>
<tr>
<td>String.prototype.lastIndexOf()</td>
<td>用法跟 indexOf 方法一致，主要的区别是 lastIndexOf 从尾部开始匹配</td>
</tr>
<tr>
<td>String.prototype.trim()</td>
<td><strong>去除</strong>字符串两端的空格（还有制表符<code>\t</code>、<code>\v</code>、换行符<code>\n</code>和回车符<code>\r</code>），返回一个新字符串，不改变原字符串。</td>
</tr>
<tr>
<td>String.prototype.toLowerCase()</td>
<td>将一个字符串全部转为小写，返回一个新字符串，不改变原字符串</td>
</tr>
<tr>
<td>String.prototype.toUpperCase()</td>
<td>将一个字符串全部转为大写，返回一个新字符串，不改变原字符串</td>
</tr>
<tr>
<td>String.prototype.match()</td>
<td>用于确定原字符串是否匹配某个子字符串，返回一个数组，包括<strong>所有</strong>匹配成功的结果。如果没有找到匹配，则返回 null</td>
</tr>
<tr>
<td>String.prototype.search()</td>
<td>search 方法的用法基本等同于 match，但是返回值为匹配的<strong>第一个位置</strong>。如果没有找到匹配，则返回-1</td>
</tr>
<tr>
<td>String.prototype.replace()</td>
<td>用于<strong>替换</strong>匹配的子字符串，一般情况下只替换第一个匹配</td>
</tr>
<tr>
<td>String.prototype.split()</td>
<td>按照给定规则<strong>分割</strong>字符串，返回一个由分割出来的子字符串组成的数组，第二个参数可限定返回数组的最大成员数</td>
</tr>
</tbody>
</table>
<h1 id="Array-有哪些方法"><a href="#Array-有哪些方法" class="headerlink" title="Array 有哪些方法"></a>Array 有哪些方法</h1><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>valueOf()</td>
<td>返回数组本身</td>
</tr>
<tr>
<td>toString()</td>
<td>返回数组的字符串形式</td>
</tr>
<tr>
<td>push()</td>
<td>在数组的<strong>末端</strong>添加一或多个元素，并返回添加新元素后的数组<strong>长度</strong></td>
</tr>
<tr>
<td>pop()</td>
<td>删除数组的<strong>最后</strong>一个元素，并返回该元素</td>
</tr>
<tr>
<td>shift()</td>
<td>删除数组的<strong>第一个</strong>元素，并返回该元素</td>
</tr>
<tr>
<td>unshift()</td>
<td>在数组的<strong>第一个</strong>位置添加元素，并返回添加新元素后的数组<strong>长度</strong></td>
</tr>
<tr>
<td>join()</td>
<td>以指定参数作为分隔符（默认逗号），将所有数组成员连接为一个<strong>字符串</strong>返回</td>
</tr>
<tr>
<td>concat()</td>
<td>合并多个数组，添加在尾部，返回新数组，<strong>原数组不变</strong></td>
</tr>
<tr>
<td>reverse()</td>
<td>颠倒排列数组元素，返回改变后的数组</td>
</tr>
<tr>
<td>slice(start, end)</td>
<td>剪切，提取目标数组的一部分，返回一个新数组，原数组不变；还可将<strong>类似数组对象</strong>转为数组</td>
</tr>
<tr>
<td>splice(start, count, addElement1, …)</td>
<td>剪接，删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是<strong>被删除</strong>的元素</td>
</tr>
<tr>
<td>sort()</td>
<td>对数组成员进行排序，默认是按照<strong>字典顺序</strong>排序</td>
</tr>
<tr>
<td>map()</td>
<td>将数组的所有成员依次传入第一个参数指定的<strong>函数</strong>（有三个参数：当前成员、当前位置和数组本身），同时第二个参数指定函数内部 this 指向的<strong>对象</strong>，然后把每一次的执行结果组成一个<strong>新数组</strong>返回</td>
</tr>
<tr>
<td>forEach()</td>
<td>对数组的所有成员依次执行参数函数，参数同 map，过程<strong>无法中断</strong>，结果无返回值</td>
</tr>
<tr>
<td>filter()</td>
<td>过滤数组成员，满足第一个参数指定函数为 true，第二个参数绑定函数内部 this 的成员组成一个新数组返回</td>
</tr>
<tr>
<td>some()</td>
<td>第一个参数指定一个函数，第二个参数函数绑定函数内部的 this，所有数组成员依次执行该函数。该函数接受三个参数：当前成员、当前位置和整个数组，同时然后返回一个布尔值，只要一个成员的返回值是true，则整个some方法的返回值就是true，否则返回false</td>
</tr>
<tr>
<td>every()</td>
<td>参数同 some，every 方法是所有成员的返回值都是 true，整个every方法才返回true，否则返回 false</td>
</tr>
<tr>
<td>reduce()</td>
<td>从左到右依次处理数组的每个成员，最终累计为一个值。第一个参数是一个函数，接受以下四个参数：累积变量，当前变量，当前位置（从0开始），原数组；第二个参数可以指定累积的初始值</td>
</tr>
<tr>
<td>reduceRight()</td>
<td>从右到左依次处理数组的每个成员，最终累计为一个值。参数同 reduce</td>
</tr>
<tr>
<td>indexOf()</td>
<td>返回给定元素在数组中第一次出现的位置，如果没有出现则返回 -1，第二个参数指定开始位置</td>
</tr>
<tr>
<td>lastIndexOf()</td>
<td>返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1</td>
</tr>
</tbody>
</table>
<h1 id="call-bind-apply-有什么区别"><a href="#call-bind-apply-有什么区别" class="headerlink" title="call bind apply 有什么区别"></a>call bind apply 有什么区别</h1><p>三者作用均是改变函数执行时的上下文，简言之就是改变函数运行时的 this 指向</p>
<ol>
<li>call 和 apply 直接执行函数，使函数 this 指向第一个参数对象，bind 是传入对象后返回一个新的函数，这个函数绑定了新的 this 环境等待调用</li>
<li>bind 和 apply 可以数组的形式传入参数，call 不可以</li>
</ol>
<h1 id="js-创建新对象有哪些方法"><a href="#js-创建新对象有哪些方法" class="headerlink" title="js 创建新对象有哪些方法"></a>js 创建新对象有哪些方法</h1><p>通过对象直接量、关键字 new、和 Object.create() 函数来创建对象</p>
<h1 id="什么是作用域-什么是作用域链"><a href="#什么是作用域-什么是作用域链" class="headerlink" title="什么是作用域, 什么是作用域链"></a>什么是作用域, 什么是作用域链</h1><p>作用域即是变量和函数生效的区域或集合。</p>
<p>在 ES6 之前，作用域分为全局作用域和函数作用域，而不存在块级作用域，这导致函数中的变量无论是在哪申明的，在编译阶段都将被提升到执行上下文的变量环境中，这些变量在函数体内部任何地方都能被访问到。</p>
<p>变量提升也有好处。一方面提高性能，js代码执行之前进行语法检查和预编译；另一方面容错性也更好，比如先赋值后定义<br>变量提升也有缺点。一方面会导致变量被覆盖；另一方面也会面临变量没有被销毁，如 for 循环时 var 定义的 i</p>
<p>作用域链是，在 js 中使用一个变量时，javascript 引擎会尝试在当前作用域下寻找该变量，若未找到，则向上层寻找，直到找到该变量或抵达全局作用域</p>
<h1 id="什么是原型-什么是原型链"><a href="#什么是原型-什么是原型链" class="headerlink" title="什么是原型, 什么是原型链"></a>什么是原型, 什么是原型链</h1><p>JavaScript 被描述为一种基于原型的语言————每个对象都拥有一个原型对象</p>
<p>每个对象都有自己的原型对象，那么任何一个对象都可以充当其他对象的原型，且由于原型对象也是对象，所有它也有自己的原型，因此形成一个原型链</p>
<h1 id="proto-和-prototype-的区别"><a href="#proto-和-prototype-的区别" class="headerlink" title="__proto__ 和 prototype 的区别"></a><code>__proto__</code> 和 prototype 的区别</h1><ul>
<li>每个对象都有 <code>__proto__</code> ，只有函数对象才有 prototype</li>
<li>js 在创建对象时，都会有一个 <code>__proto__</code> 内置属性，用于指向创建它的构造函数的原型对象</li>
<li>所有函数对象的 <code>__proto__</code> 都指向 Function.prototype</li>
</ul>
<h1 id="js-实现继承的方式"><a href="#js-实现继承的方式" class="headerlink" title="js 实现继承的方式"></a>js 实现继承的方式</h1><ol>
<li>原型链继承</li>
<li>借用构造函数（经典继承）</li>
<li>组合式继承</li>
<li>原型式继承</li>
<li>寄生式继承</li>
<li>寄生组合式继承</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寄生组合式继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span> (<span class="params">parent, child</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里改用 Object.create 就可以减少组合继承中多进行一次构造的过程</span></span><br><span class="line">    child.prototype = <span class="built_in">Object</span>.create(parent.prototype);</span><br><span class="line">    child.prototype.constructor = child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'parent'</span>;</span><br><span class="line">    <span class="keyword">this</span>.play = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.friends = <span class="string">'child'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">clone(Parent, Child);</span><br><span class="line"></span><br><span class="line">Child.prototype.getFriends = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.friends;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Child();</span><br></pre></td></tr></table></figure>
<h1 id="对-this-的理解"><a href="#对-this-的理解" class="headerlink" title="对 this 的理解"></a>对 this 的理解</h1><p>this 是函数运行时内部生成的一个对象，只能在函数内部使用，总是指向调用它的对象,在函数体内部，指代函数当前的运行环境。</p>
<ol>
<li>this 总是指向函数的直接调用者，而非间接调用者</li>
<li>如果有 new 关键字，this 指向 new 出来的那个对象</li>
<li>在事件中，this 指向目标元素</li>
</ol>
<h1 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别"></a>箭头函数和普通函数的区别</h1><ol>
<li><p>没有 this。需要通过查找作用域链来确定 this 的值，this 也就成了最近一层非箭头函数的 this；此外箭头函数没有 this，所以也不能用 call、apply、bind 这些方法 改变 this 指向</p>
</li>
<li><p>没有 arguments 。箭头函数没有自己的 arguments 对象，访问到的是外层函数的 arguments 对象，想要访问箭头函数的参数，可以使用 rest 参数的形式</p>
</li>
<li><p>不能通过 new 关键字调用。JavaScript 函数有两个内部方法：<code>[[Call]]</code> 和 <code>[[Construct]]</code>。</p>
</li>
</ol>
<p>当通过 new 调用函数时，执行 <code>[[Construct]]</code> 方法，创建一个实例对象，然后再执行函数体，将 this 绑定到实例上。</p>
<p>当直接调用的时候，执行 <code>[[Call]]</code> 方法，直接执行函数体。</p>
<p>箭头函数并没有 <code>[[Construct]]</code> 方法，不能被用作构造函数，如果通过 new 的方式调用，会报错。</p>
<ol start="4">
<li><p>没有 new.target。不能使用 new 调用，也就没有 new.target</p>
</li>
<li><p>没有原型。不能使用 new 调用箭头函数，所以也没有构建原型的需求，不存在 prototype 属性</p>
</li>
<li><p>没有 super。没有原型</p>
</li>
</ol>
<h1 id="什么是闭包，闭包的优点和缺点"><a href="#什么是闭包，闭包的优点和缺点" class="headerlink" title="什么是闭包，闭包的优点和缺点"></a>什么是闭包，闭包的优点和缺点</h1><p>闭包指的是一个函数可以访问另一个函数作用域中的变量，闭包的原理是作用域链。<br>优点是避免全局变量污染，缺点是容易造成内存泄露</p>
<p>可以应用于函数柯里化，柯里化的目的在于避免频繁调用具有相同参数的函数，同时又方便重用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设我们有一个求长方形面积的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArea</span>(<span class="params">width, height</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> width * height</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果我们碰到的长方形的宽老是10</span></span><br><span class="line"><span class="keyword">const</span> area1 = getArea(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="keyword">const</span> area2 = getArea(<span class="number">10</span>, <span class="number">30</span>)</span><br><span class="line"><span class="keyword">const</span> area3 = getArea(<span class="number">10</span>, <span class="number">40</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们可以使用闭包柯里化这个计算面积的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArea</span>(<span class="params">width</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">height</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> width * height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getTenWidthArea = getArea(<span class="number">10</span>)</span><br><span class="line"><span class="comment">// 之后碰到宽度为10的长方形就可以这样计算面积</span></span><br><span class="line"><span class="keyword">const</span> area1 = getTenWidthArea(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 而且如果遇到宽度偶尔变化也可以轻松复用</span></span><br><span class="line"><span class="keyword">const</span> getTwentyWidthArea = getArea(<span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<h1 id="如何用一个函数生成对象时设置不用-new-关键字报错"><a href="#如何用一个函数生成对象时设置不用-new-关键字报错" class="headerlink" title="如何用一个函数生成对象时设置不用 new 关键字报错"></a>如何用一个函数生成对象时设置不用 new 关键字报错</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">Person(<span class="string">"jake"</span>) <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">new</span> Person(<span class="string">"jake"</span>) <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
<p>answer：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Person)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'error msg'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实在 vue 中我们就有见到过, Vue 本身是一个函数，只不过在其上定义了很多属性，以及原型上定义了各类方法，我们在使用时需要用 new 来创建一个 vue 实例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">    !(<span class="keyword">this</span> <span class="keyword">instanceof</span> Vue)</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(<span class="string">'Vue is a constructor and should be called with the `new` keyword'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>._init(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="js-异步通信，对-Ajax-的了解"><a href="#js-异步通信，对-Ajax-的了解" class="headerlink" title="js 异步通信，对 Ajax 的了解"></a>js 异步通信，对 Ajax 的了解</h1><p>Ajax 是通过 JavaScript 的异步通信（jquery 对 xhr 的封装）<br>在向服务器发送请求的时候，可以同时做其他事情，等实现特定结果，再进行后续操作，使页面发送局部更新。</p>
<p>过程：</p>
<ol>
<li>创建 XMLHTTPRequest 对象  <code>const xhr = new XMLHTTPRequest()</code></li>
<li>创建新的 HTTP 请求  <code>xhr.open(&#39;get&#39;, url, true)</code></li>
<li>设置响应 HTTP 请求状态变化的函数 onreadystatechange</li>
<li>发送 HTTP 请求  <code>xhr.send(data)</code></li>
<li>获取异步通信的结果</li>
</ol>
<h1 id="js-深浅拷贝"><a href="#js-深浅拷贝" class="headerlink" title="js 深浅拷贝"></a>js 深浅拷贝</h1><ol>
<li>浅拷贝</li>
</ol>
<ul>
<li>Object.assign 实现浅拷贝，Object.assign 只会拷贝所有的属性值到新的对象中，如果属性值是对象的话，拷贝的则是地址。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  age: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Object</span>.assign(&#123;&#125;, a)</span><br><span class="line">a.age = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(b.age) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>展开运算符 <code>...</code> 实现浅拷贝</li>
</ul>
<ol start="2">
<li>深拷贝</li>
</ol>
<ul>
<li>通常可以用 <code>JSON.parse(JSON.stringify(object))</code> 实现深拷贝，但是该方法也有局限性<ul>
<li>会忽略 undefined</li>
<li>会忽略 symbol</li>
<li>不能序列化函数</li>
<li>不能解决循环引用的对象</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  age: <span class="literal">undefined</span>,</span><br><span class="line">  sex: <span class="built_in">Symbol</span>(<span class="string">'male'</span>),</span><br><span class="line">  jobs: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  name: <span class="string">'yck'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a))</span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// &#123;name: "yck"&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>所需拷贝的对象含有内置类型并且不包含函数，可以使用 MessageChannel</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">structuralClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; port1, port2 &#125; = <span class="keyword">new</span> MessageChannel()</span><br><span class="line">    port2.onmessage = <span class="function"><span class="params">ev</span> =&gt;</span> resolve(ev.data)</span><br><span class="line">    port1.postMessage(obj)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: &#123;</span><br><span class="line">    c: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.b.d = obj.b</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意该方法是异步的</span></span><br><span class="line"><span class="comment">// 可以处理 undefined 和循环引用对象</span></span><br><span class="line"><span class="keyword">const</span> test = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> clone = <span class="keyword">await</span> structuralClone(obj)</span><br><span class="line">  <span class="built_in">console</span>.log(clone)</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure>
<ul>
<li>lodash 的深拷贝函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">typeof</span> o === <span class="string">'object'</span> || <span class="keyword">typeof</span> o === <span class="string">'function'</span>) &amp;&amp; o !== <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isObject(obj)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'非对象'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> isArray = <span class="built_in">Array</span>.isArray(obj)</span><br><span class="line">  <span class="keyword">let</span> newObj = isArray ? [...obj] : &#123; ...obj &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对属性进行遍历，如果属性为对象，递归处理</span></span><br><span class="line">  <span class="built_in">Reflect</span>.ownKeys(newObj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    newObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> newObj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  a: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  b: &#123;</span><br><span class="line">    c: <span class="number">2</span>,</span><br><span class="line">    d: <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newObj = deepClone(obj)</span><br><span class="line">newObj.b.c = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.b.c) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>循环递归</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj, hash = new WeakMap(</span>)) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj === <span class="literal">null</span>) <span class="keyword">return</span> obj; <span class="comment">// 如果是null或者undefined我就不进行拷贝操作</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(obj);</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj);</span><br><span class="line">  <span class="comment">// 可能是对象或者普通的值  如果是函数的话是不需要深拷贝</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">"object"</span>) <span class="keyword">return</span> obj;</span><br><span class="line">  <span class="comment">// 是对象的话就要进行深拷贝</span></span><br><span class="line">  <span class="keyword">if</span> (hash.get(obj)) <span class="keyword">return</span> hash.get(obj);</span><br><span class="line">  <span class="keyword">let</span> cloneObj = <span class="keyword">new</span> obj.constructor();</span><br><span class="line">  <span class="comment">// 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身</span></span><br><span class="line">  hash.set(obj, cloneObj);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      <span class="comment">// 实现一个递归拷贝</span></span><br><span class="line">      cloneObj[key] = deepClone(obj[key], hash);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cloneObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="async-是什么的语法糖"><a href="#async-是什么的语法糖" class="headerlink" title="async 是什么的语法糖"></a>async 是什么的语法糖</h1><p>async 函数是 Generator 函数的语法糖。实际上就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await</p>
<p>async 函数对 对 Generator 函数的改进，体现在四点：</p>
<ol>
<li><p>Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器，与普通函数一样执行</p>
</li>
<li><p>async 和 await，比起星号和 yield，语义更清楚了。</p>
</li>
<li><p>async 函数的 await 命令后面，可以是 Promise 对象和原始类型的值</p>
</li>
<li><p>async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作</p>
</li>
</ol>
<h1 id="promise-有几种状态-又是怎么转变状态的"><a href="#promise-有几种状态-又是怎么转变状态的" class="headerlink" title="promise 有几种状态, 又是怎么转变状态的"></a>promise 有几种状态, 又是怎么转变状态的</h1><p>有 pending、fulfilled、rejected 三种状态，promise 函数执行进入 pending 状态，通过 resolve 函数 会将 fulfilled 成功状态，通过 reject 函数将进行状态转为失败状态</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://juejin.im/post/6868843713729134599/" target="_blank" rel="noopener">金九银十，初中级前端面试复习总结「JavaScript篇」</a></p>

      
    </div>
    <br>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/blog/categories/notes/">notes</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Frontend/">Frontend</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/interview/">interview</a></li></ul>

      
	<span class="ico-date"></span>
	<a href="/blog/2020/08/25/1-interview-js/" class="article-date">
	  <time datetime="2020-08-25T03:20:33.000Z" itemprop="datePublished">八月 25, 2020</time>
	</a>

      <!-- 添加字数统计 -->
      
        <span class="ico-fontcount"></span><span class="post-count">4.8k字</span>
      
    </footer>
    <!-- 文章添加评论 -->
    
      
    <script defer src="//unpkg.com/leancloud-storage@4/dist/av-min.js"></script>
    <script defer src='//unpkg.com/valine@latest/dist/Valine.min.js'></script>
    <div id="vcomments"></div>
    <script>

        var notify = 'false' == true ? true : false;
        var verify = 'false' == true ? true : false;
		// 设置轮询
		const timer = setInterval(() => {
			if (window.Valine && typeof window.Valine === 'function') {
				clearInterval(timer);
				new Valine({
					el: '#vcomments',
					notify: notify,
					verify: verify,
					app_id: 'AJj6aG4cDMBqBIISAr1U53Az-gzGzoHsz',
					app_key: 'bIYBhlht4PSXI4pCWuH7Gnuo',
					placeholder: 'say something bro ~',
					avatar: 'monsterid',
					avatarCDN:'https://cravatar.cn/avatar/'
				});
			}
		}, 1000);
    </script>



    
    <hr class="entry-footer-hr">
  </div>
  
    
<nav id="article-nav">
  
    <a href="/blog/2020/08/26/1-interview-html&css/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          🔥 面试 | HTML &amp; CSS
        
      </div>
    </a>
  
  
    <a href="/blog/2020/08/15/2-backend-docker/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">🔥 docker 学习笔记</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    
      <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#js-基础数据类型有哪些（字节）"><span class="nav-number">1.</span> <span class="nav-text">js 基础数据类型有哪些（字节）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#对数据类型的检测（字节）"><span class="nav-number">2.</span> <span class="nav-text">对数据类型的检测（字节）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#js如何判断数组是Array类型（字节）"><span class="nav-number">3.</span> <span class="nav-text">js如何判断数组是Array类型（字节）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#如何理解-slice-call-arguments"><span class="nav-number">4.</span> <span class="nav-text">如何理解 [].slice.call(arguments)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#如何检测一个空对象"><span class="nav-number">5.</span> <span class="nav-text">如何检测一个空对象</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0-1-0-2-0-3"><span class="nav-number">6.</span> <span class="nav-text">0.1 + 0.2 == 0.3 ?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#null-和-undefined-的区别"><span class="nav-number">7.</span> <span class="nav-text">null 和 undefined 的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#js-中有几种类型的值"><span class="nav-number">8.</span> <span class="nav-text">js 中有几种类型的值</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#操作符的强制类型转换规则"><span class="nav-number">9.</span> <span class="nav-text">== 操作符的强制类型转换规则</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#String-有哪些方法（实例方法）"><span class="nav-number">10.</span> <span class="nav-text">String 有哪些方法（实例方法）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Array-有哪些方法"><span class="nav-number">11.</span> <span class="nav-text">Array 有哪些方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#call-bind-apply-有什么区别"><span class="nav-number">12.</span> <span class="nav-text">call bind apply 有什么区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#js-创建新对象有哪些方法"><span class="nav-number">13.</span> <span class="nav-text">js 创建新对象有哪些方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#什么是作用域-什么是作用域链"><span class="nav-number">14.</span> <span class="nav-text">什么是作用域, 什么是作用域链</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#什么是原型-什么是原型链"><span class="nav-number">15.</span> <span class="nav-text">什么是原型, 什么是原型链</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#proto-和-prototype-的区别"><span class="nav-number">16.</span> <span class="nav-text">__proto__ 和 prototype 的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#js-实现继承的方式"><span class="nav-number">17.</span> <span class="nav-text">js 实现继承的方式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#对-this-的理解"><span class="nav-number">18.</span> <span class="nav-text">对 this 的理解</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#箭头函数和普通函数的区别"><span class="nav-number">19.</span> <span class="nav-text">箭头函数和普通函数的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#什么是闭包，闭包的优点和缺点"><span class="nav-number">20.</span> <span class="nav-text">什么是闭包，闭包的优点和缺点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#如何用一个函数生成对象时设置不用-new-关键字报错"><span class="nav-number">21.</span> <span class="nav-text">如何用一个函数生成对象时设置不用 new 关键字报错</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#js-异步通信，对-Ajax-的了解"><span class="nav-number">22.</span> <span class="nav-text">js 异步通信，对 Ajax 的了解</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#js-深浅拷贝"><span class="nav-number">23.</span> <span class="nav-text">js 深浅拷贝</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#async-是什么的语法糖"><span class="nav-number">24.</span> <span class="nav-text">async 是什么的语法糖</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#promise-有几种状态-又是怎么转变状态的"><span class="nav-number">25.</span> <span class="nav-text">promise 有几种状态, 又是怎么转变状态的</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考链接"><span class="nav-number">26.</span> <span class="nav-text">参考链接</span></a></li></ol>
    
    </div>
  </aside>
</section>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">HOME</a>
  
    <a href="/blog/archives" class="mobile-nav-link">ARCHIVES</a>
  
    <a href="/blog/categories" class="mobile-nav-link">CATEGORIES</a>
  
    <a href="/blog/about" class="mobile-nav-link">ABOUT</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2025 Arginsen&#39;s Blog All Rights Reserved.
      </div>
      <div class="site-credit">
        ID  <a href="https://lixupeng.cn" target="_blank">Arginsen</a>
      </div>
      <br>
      <div class="busuanzi-analytics">
        
        <span id="busuanzi_container_site_pv">
          本站总访问量<span id="busuanzi_value_site_pv"></span>次
        </span>
        <span class="post-meta-divider">|</span>
        <!-- <span id="busuanzi_container_site_uv">
          本站访客数<span id="busuanzi_value_site_uv"></span>人
        </span> -->
        <span class="post-count">全站共 335.3k 字</span>
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        
      </div>
  </div> 
</footer>
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">
  <script src="/blog/fancybox/jquery.fancybox.pack.js"></script>


<script src="/blog/js/script.js"></script>
<script src="/blog/js/bootstrap.js"></script>
<script src="/blog/js/main.js"></script>







  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>


<script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?bb74e3da22205cadfa4f6e0a31a76ac4";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
</script>
    


  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/blog/js/totop.js" async=""></script>
</body>
</html>
