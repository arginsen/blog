---
title: 数据结构 | C 与 C++ 描述 | 一、基本概念与算法评价
date: 2020-9-24
tags: 
  - dataStructure
  - c
  - 考研
categories: notes
photos:
  - /blog/img/dataStructure.jpg
---

<br>
<!--more-->

# 数据结构基本概念

## 数据

> 数据是**信息的载体**，是**描述客观事物属性**的数、字符及所有能输入到计算机中并被计算机程序**识别和处理**的符号的集合。数据是计算机程序加工的原料

## 数据元素

> 数据元素是数据的**基本单位**。一个数据元素可由若干数据项组成，数据项是构成数据元素不可分割的最小的单位

## 数据对象

> 数据对象是具有**相同性质**的数据元素的集合

## 数据类型

> 数据类型是**一个值的集合**和**定义在此集合上的一组操作**的总称

1. 原子类型。其值不可再分的数据类型
2. 结构类型。其值可以在分解为若干成分（分量）的数据类型
3. 抽象数据类型。抽象数据组织（逻辑结构）及与之相关的操作。（可以此定义一个完整的数据结构）

# 数据结构三要素

> 逻辑结构、存储结构、数据的运算

## 逻辑结构

> 数据之间的逻辑关系，即从逻辑关系上描述数据，与数据存储无关

没关系 - 集合
一对一 - 线性表
一对多 - 树
多对多 - 图

![](/blog/img/2020/data-structure/data/1.png)

## 存储结构

> - 指数据结构在计算机中的表示（又称映像），也称物理结构。
> - 存储结构包括**数据元素**的表示和**关系**的表示。
> - 数据的存储结构主要有顺序存储、链式存储、索引存储、散列存储

1. 顺序存储。
  1) 把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。
  2) 其优点是可以实现随机存取，每个元素占用最少的存储空间；
  3) 缺点是只能使用相邻的一整块存储单 元，因此可能产生较多的外部碎片。

2. 链式存储。
  1) 不要求逻辑上相邻的元素在物理位置上也相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系。
  2) 其优点是不会出现碎片现象，能充分利用所有存储单元；
  3) 缺点是每个元素因存储指针而占用额外的存储空间，且只能实现顺序存取。

3. 索引存储。
  1) 在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为索引项,索引项的一-般形式是(关键字，地址)。
  2) 其优点是检索速度快；
  3) 缺点是附加的索引表额外占用存储空间。另外，增加和删除数据时也要修改索引表，因而会花费较多的时间。

4. 散列存储。
  1) 根据元素的关键字直接计算出该元素的存储地址，又称哈希(Hash) 存储。
  2) 其优点是检索、增加和删除结点的操作都很快；
  3) 缺点是若散列函数不好，则可能出现元素存储单元的冲突，而解决冲突会增加时间和空间开销。



## 数据的运算

> - 施加在数据上的运算包括运算的**定义**和**实现**
> - 运算的定义是针对逻辑结构，指出运算的功能
> - 运算的实现是针对存储结构的，指出运算的具体操作步骤

# 算法分析

## 时间复杂度

- 把加减乘除比较和赋值都视作耗时相同的运算

规则：
1.一次循环运行时间是循环内语句的运行时间乘以循环次数
2.嵌套循环运行时间为最内层语句执行次数乘以总循环次数
3.并列的两个循环运行时间与执行次数数量级大的那个相同

```c++
// 递归函数时间复杂度分析
int x = 2;
while(x < n/2)
    x = 2 * x;

// 第 1 次是 4，2的 2 次方
// 第 2 次是 8，2的 3 次方
// ...
// 第 k 次是 2 的 k=1 次方
// 2^(k+1) < n/2
// 则 k < log2(n/2) - 1
// 因此时间复杂度就为 O(log2(n))


// 嵌套循环函数时间复杂度分析
int x = 1;
for(int i = 0; i < n; i++) {
    for(int j = i; j < n; j++) {
        x++;
    }
}

// i=0，内层执行 n 次
// i=1，内层执行 n-1 次
// ...
// i=k，内层执行 n-k 次
// ...
// i=n-1，内层执行 1 次
// 因此总共执行 n(n+1) / 2 次
// 因此时间复杂度就为 O(n^2)
```

## 空间复杂度